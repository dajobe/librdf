##
## redland.pod - redland Unix manual page
##
## $Id$
##
## Copyright (C) 2002 David Beckett - http://purl.org/net/dajobe/
## Institute for Learning and Research Technology - http://www.ilrt.org/
## University of Bristol - http://www.bristol.ac.uk/
## 
## This package is Free Software or Open Source available under the
## following licenses (these are alternatives):
##   1. GNU Lesser General Public License (LGPL)
##   2. GNU General Public License (GPL)
##   3. Mozilla Public License (MPL)
## 
## See LICENSE.html or LICENSE.txt at the top of this package for the
## full license terms.
## 
## 

=pod

=head1 NAME

B<redland> - Redland RDF Library

=head1 VERSION

redland REDLAND_VERSION_STRING

=head1 SYNOPSIS

 #include <librdf.h>

=head1 DESCRIPTION

The B<redland> library is a general RDF library written in ANSI C
that provides application support for the RDF model, ...

=head1 FUNCTIONS

The functions defined by B<redland> are all defined with the
C<librdf_> prefix

=head2 class world

=over 4

=item librdf_world* B<librdf_new_world>(I<void>);

=item void B<librdf_free_world>(librdf_world *I<world>);

=item void B<librdf_world_open>(librdf_world *I<world>);

=item void B<librdf_world_set_error>(librdf_world* I<world>, void *I<user_data>, void (*I<error_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_world_set_warning>(librdf_world* I<world>, void *I<user_data>, void (*I<warning_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_world_set_digest>(librdf_world*, const char *I<name>);

=item void B<librdf_world_set_uris_hash>(librdf_world* I<world>, librdf_hash* I<uris_hash>);

=item const char *B<librdf_world_get_feature>(librdf_world* I<world>, librdf_uri *I<feature>);

=item int B<librdf_world_set_feature>(librdf_world* I<world>, librdf_uri *I<feature>, const char *I<value>);

=item void B<librdf_init_world>(char *I<digest_factory_name>, librdf_hash* I<uris_hash>);

=item void B<librdf_destroy_world>(I<void>);

=back

=head2 class iterator

=over 4

=item librdf_iterator* B<librdf_new_iterator>(librdf_world *I<world>, void *I<context>, int (*I<is_end>)(void*), void* (*I<get_next>)(void*), void (*I<finished>)(void*));

=item void B<librdf_free_iterator>(librdf_iterator*);

=item int B<librdf_iterator_end>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_have_elements>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_finished>(librdf_iterator* I<iterator>);

=item void* B<librdf_iterator_get_next>(librdf_iterator* I<iterator>);

=item int B<librdf_iterator_add_map>(librdf_iterator* I<iterator>, void* (*I<fn>)(void *I<context>, void *I<item>), void *I<context>);

=item void* B<librdf_iterator_map_remove_duplicate_nodes>(void *I<item>, void *I<user_data>);

=back

=head2 class digest

=over 4

=item void B<librdf_digest_register_factory>(librdf_world *I<world>, const char *I<name>, void (*I<factory>) (librdf_digest_factory*));

=item librdf_digest_factory* B<librdf_get_digest_factory>(librdf_world *I<world>, const char *I<name>);

=item void B<librdf_init_digest>(librdf_world *I<world>);

=item void B<librdf_finish_digest>(librdf_world *I<world>);

=item librdf_digest* B<librdf_new_digest>(librdf_world *I<world>, char *I<name>);

=item librdf_digest* B<librdf_new_digest_from_factory>(librdf_world *I<world>, librdf_digest_factory *I<factory>);

=item void B<librdf_free_digest>(librdf_digest *I<digest>);

=item void B<librdf_digest_init>(librdf_digest* I<digest>);

=item void B<librdf_digest_update>(librdf_digest* I<digest>, unsigned char *I<buf>, size_t I<length>);

=item void B<librdf_digest_final>(librdf_digest* I<digest>);

=item void* B<librdf_digest_get_digest>(librdf_digest* I<digest>);

=item char* B<librdf_digest_to_string>(librdf_digest* I<digest>);

=item void B<librdf_digest_print>(librdf_digest* I<digest>, FILE* I<fh>);

=back

=head2 class uri

=over 4

=item void B<librdf_init_uri>(librdf_world *I<world>);

=item void B<librdf_finish_uri>(librdf_world *I<world>);

=item void B<librdf_free_uri>(librdf_uri *I<uri>);

=item int B<librdf_uri_equals>(librdf_uri* I<first_uri>, librdf_uri* I<second_uri>);

=item int B<librdf_uri_is_file_uri>(librdf_uri* I<uri>);

=item const char* B<librdf_uri_as_filename>(librdf_uri* I<uri>);

=item librdf_uri* B<librdf_new_uri_normalised_to_base>(const char *I<uri_string>, librdf_uri* I<source_uri>, librdf_uri* I<base_uri>);

=item librdf_uri* B<librdf_new_uri_relative_to_base>(librdf_uri* I<base_uri>, const char *I<uri_string>);

=back

=head2 class node

=over 4

=item void B<librdf_init_node>(librdf_world* I<world>);

=item void B<librdf_finish_node>(librdf_world* I<world>);

=item librdf_node* B<librdf_new_node>(librdf_world* I<world>);

=item librdf_node* B<librdf_new_node_from_uri_string>(librdf_world* I<world>, const char *I<string>);

=item librdf_node* B<librdf_new_node_from_uri>(librdf_world* I<world>, librdf_uri *I<uri>);

=item librdf_node* B<librdf_new_node_from_uri_local_name>(librdf_world* I<world>, librdf_uri *I<uri>, const char *I<local_name>);

=item librdf_node* B<librdf_new_node_from_normalised_uri_string>(librdf_world* I<world>, const char *I<uri_string>, librdf_uri *I<source_uri>, librdf_uri *I<base_uri>);

=item librdf_node* B<librdf_new_node_from_literal>(librdf_world* I<world>, const char *I<string>, const char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item librdf_node* B<librdf_new_node_from_node>(librdf_node *I<node>);

=item void B<librdf_node_init>(librdf_world *I<world>, librdf_node *I<node>);

=item void B<librdf_free_node>(librdf_node *I<r>);

=item librdf_uri* B<librdf_node_get_uri>(librdf_node* I<node>);

=item int B<librdf_node_set_uri>(librdf_node* I<node>, librdf_uri *I<uri>);

=item librdf_node_type B<librdf_node_get_type>(librdf_node* I<node>);

=item void B<librdf_node_set_type>(librdf_node* I<node>, librdf_node_type I<type>);

=item char* B<librdf_node_get_literal_value>(librdf_node* I<node>);

=item char* B<librdf_node_get_literal_value_as_latin1>(librdf_node* I<node>);

=item char* B<librdf_node_get_literal_value_language>(librdf_node* I<node>);

=item int B<librdf_node_get_literal_value_xml_space>(librdf_node* I<node>);

=item int B<librdf_node_get_literal_value_is_wf_xml>(librdf_node* I<node>);

=item int B<librdf_node_set_literal_value>(librdf_node* I<node>, const char* I<value>, const char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item int B<librdf_node_get_li_ordinal>(librdf_node* I<node>);

=item void B<librdf_node_set_li_ordinal>(librdf_node* I<node>, int I<ordinal>);

=item librdf_digest* B<librdf_node_get_digest>(librdf_node* I<node>);

=item size_t B<librdf_node_encode>(librdf_node* I<node>, unsigned char *I<buffer>, size_t I<length>);

=item size_t B<librdf_node_decode>(librdf_node* I<node>, unsigned char *I<buffer>, size_t I<length>);

=item char *B<librdf_node_to_string>(librdf_node* I<node>);

=item void B<librdf_node_print>(librdf_node* I<node>, FILE *I<fh>);

=item int B<librdf_node_equals>(librdf_node* I<first_node>, librdf_node* I<second_node>);

=back

=head2 class concepts

=over 4

=item void B<librdf_init_concepts>(librdf_world *I<world>);

=item void B<librdf_finish_concepts>(librdf_world *I<world>);

=item void B<librdf_get_concept_by_name>(librdf_world *I<world>, int I<is_ms>, const char *I<name>, librdf_uri **I<uri_p>, librdf_node **I<node_p>);

=back

=head2 class statement

=over 4

=item void B<librdf_init_statement>(librdf_world *I<world>);

=item void B<librdf_finish_statement>(librdf_world *I<world>);

=item librdf_statement* B<librdf_new_statement>(librdf_world* I<world>);

=item librdf_statement* B<librdf_new_statement_from_statement>(librdf_statement* I<statement>);

=item librdf_statement* B<librdf_new_statement_from_nodes>(librdf_world *I<world>, librdf_node* I<subject>, librdf_node* I<predicate>, librdf_node* I<object>);

=item void B<librdf_statement_init>(librdf_world *I<world>, librdf_statement *I<statement>);

=item void B<librdf_free_statement>(librdf_statement* I<statement>);

=item librdf_node* B<librdf_statement_get_subject>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_subject>(librdf_statement *I<statement>, librdf_node *I<subject>);

=item librdf_node* B<librdf_statement_get_predicate>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_predicate>(librdf_statement *I<statement>, librdf_node *I<predicate>);

=item librdf_node* B<librdf_statement_get_object>(librdf_statement *I<statement>);

=item void B<librdf_statement_set_object>(librdf_statement *I<statement>, librdf_node *I<object>);

=item char *B<librdf_statement_to_string>(librdf_statement *I<statement>);

=item void B<librdf_statement_print>(librdf_statement *I<statement>, FILE *I<fh>);

=item int B<librdf_statement_equals>(librdf_statement* I<statement1>, librdf_statement* I<statement2>);

=item int B<librdf_statement_match>(librdf_statement* I<statement>, librdf_statement* I<partial_statement>);

=item size_t B<librdf_statement_encode>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>);

=item size_t B<librdf_statement_encode_parts>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>, int I<fields>);

=item size_t B<librdf_statement_decode>(librdf_statement* I<statement>, unsigned char *I<buffer>, size_t I<length>);

=back

=head2 class model

=over 4

=item void B<librdf_init_model>(librdf_world *I<world>);

=item void B<librdf_finish_model>(librdf_world *I<world>);

=item librdf_model* B<librdf_new_model>(librdf_world *I<world>, librdf_storage *I<storage>, char* I<options_string>);

=item librdf_model* B<librdf_new_model_with_options>(librdf_world *I<world>, librdf_storage *I<storage>, librdf_hash* I<options>);

=item librdf_model* B<librdf_new_model_from_model>(librdf_model* I<model>);

=item void B<librdf_free_model>(librdf_model *I<model>);

=item int B<librdf_model_size>(librdf_model* I<model>);

=item int B<librdf_model_add>(librdf_model* I<model>, librdf_node* I<subject>, librdf_node* I<predicate>, librdf_node* I<object>);

=item int B<librdf_model_add_string_literal_statement>(librdf_model* I<model>, librdf_node* I<subject>, librdf_node* I<predicate>, char* I<string>, char *I<xml_language>, int I<xml_space>, int I<is_wf_xml>);

=item int B<librdf_model_add_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_add_statements>(librdf_model* I<model>, librdf_stream* I<statement_stream>);

=item int B<librdf_model_remove_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_contains_statement>(librdf_model* I<model>, librdf_statement* I<statement>);

=item int B<librdf_model_has_arc_in>(librdf_model *I<model>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_model_has_arc_out>(librdf_model *I<model>, librdf_node *I<node>, librdf_node *I<property>);

=item librdf_stream* B<librdf_model_serialise>(librdf_model* I<model>);

=item librdf_stream* B<librdf_model_find_statements>(librdf_model* I<model>, librdf_statement* I<statement>);

=item librdf_iterator* B<librdf_model_get_sources>(librdf_model *I<model>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_model_get_arcs>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_model_get_targets>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_node* B<librdf_model_get_source>(librdf_model *I<model>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_node* B<librdf_model_get_arc>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_node* B<librdf_model_get_target>(librdf_model *I<model>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_iterator* B<librdf_model_get_arcs_in>(librdf_model *I<model>, librdf_node *I<node>);

=item librdf_iterator* B<librdf_model_get_arcs_out>(librdf_model *I<model>, librdf_node *I<node>);

=item int B<librdf_model_add_submodel>(librdf_model* I<model>, librdf_model* I<sub_model>);

=item int B<librdf_model_remove_submodel>(librdf_model* I<model>, librdf_model* I<sub_model>);

=item void B<librdf_model_print>(librdf_model *I<model>, FILE *I<fh>);

=item int B<librdf_model_add_statements_group>(librdf_model* I<model>, librdf_uri* I<group_uri>, librdf_stream* I<stream>);

=item int B<librdf_model_remove_statements_group>(librdf_model* I<model>, librdf_uri* I<group_uri>);

=back

=head2 class storage

=over 4

=item void B<librdf_init_storage>(librdf_world *I<world>);

=item void B<librdf_finish_storage>(librdf_world *I<world>);

=item void B<librdf_storage_register_factory>(const char *I<name>, void (*I<factory>) (librdf_storage_factory*));

=item librdf_storage_factory* B<librdf_get_storage_factory>(const char *I<name>);

=item librdf_storage* B<librdf_new_storage>(librdf_world *I<world>, char *I<storage_name>, char *I<name>, char *I<options_string>);

=item librdf_storage* B<librdf_new_storage_from_factory>(librdf_world *I<world>, librdf_storage_factory* I<factory>, char *I<name>, librdf_hash* I<options>);

=item void B<librdf_free_storage>(librdf_storage *I<storage>);

=item int B<librdf_storage_open>(librdf_storage* I<storage>, librdf_model *I<model>);

=item int B<librdf_storage_close>(librdf_storage* I<storage>);

=item int B<librdf_storage_get>(librdf_storage* I<storage>, void *I<key>, size_t I<key_len>, void **I<value>, size_t* I<value_len>, unsigned int I<flags>);

=item int B<librdf_storage_size>(librdf_storage* I<storage>);

=item int B<librdf_storage_add_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item int B<librdf_storage_add_statements>(librdf_storage* I<storage>, librdf_stream* I<statement_stream>);

=item int B<librdf_storage_remove_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item int B<librdf_storage_contains_statement>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item librdf_stream* B<librdf_storage_serialise>(librdf_storage* I<storage>);

=item librdf_stream* B<librdf_storage_find_statements>(librdf_storage* I<storage>, librdf_statement* I<statement>);

=item librdf_iterator* B<librdf_storage_get_sources>(librdf_storage *I<storage>, librdf_node *I<arc>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_storage_get_arcs>(librdf_storage *I<storage>, librdf_node *I<source>, librdf_node *I<target>);

=item librdf_iterator* B<librdf_storage_get_targets>(librdf_storage *I<storage>, librdf_node *I<source>, librdf_node *I<arc>);

=item librdf_iterator* B<librdf_storage_get_arcs_in>(librdf_storage *I<storage>, librdf_node *I<node>);

=item librdf_iterator* B<librdf_storage_get_arcs_out>(librdf_storage *I<storage>, librdf_node *I<node>);

=item int B<librdf_storage_has_arc_in>(librdf_storage *I<storage>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_storage_has_arc_out>(librdf_storage *I<storage>, librdf_node *I<node>, librdf_node *I<property>);

=item int B<librdf_storage_group_add_statement>(librdf_storage* I<storage>, librdf_uri* I<group_uri>, librdf_statement* I<statement>);

=item int B<librdf_storage_group_remove_statement>(librdf_storage* I<storage>, librdf_uri* I<group_uri>, librdf_statement* I<statement>);

=item librdf_stream* B<librdf_storage_group_serialise>(librdf_storage* I<storage>, librdf_uri* I<group_uri>);

=back

=head2 class parser

=over 4

=item void B<librdf_parser_register_factory>(librdf_world *I<world>, const char *I<name>, const char *I<mime_type>, const char *I<uri_string>, void (*I<factory>) (librdf_parser_factory*));

=item librdf_parser_factory* B<librdf_get_parser_factory>(librdf_world *I<world>, const char *I<name>, const char *I<mime_type>, librdf_uri *I<type_uri>);

=item void B<librdf_init_parser>(librdf_world *I<world>);

=item void B<librdf_finish_parser>(librdf_world *I<world>);

=item librdf_parser* B<librdf_new_parser>(librdf_world* I<world>, const char *I<name>, const char *I<mime_type>, librdf_uri *I<type_uri>);

=item librdf_parser* B<librdf_new_parser_from_factory>(librdf_world* I<world>, librdf_parser_factory *I<factory>);

=item void B<librdf_free_parser>(librdf_parser *I<parser>);

=item librdf_stream* B<librdf_parser_parse_as_stream>(librdf_parser* I<parser>, librdf_uri* I<uri>, librdf_uri* I<base_uri>);

=item int B<librdf_parser_parse_into_model>(librdf_parser* I<parser>, librdf_uri* I<uri>, librdf_uri* I<base_uri>, librdf_model* I<model>);

=item void B<librdf_parser_set_error>(librdf_parser* I<parser>, void *I<user_data>, void (*I<error_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item void B<librdf_parser_set_warning>(librdf_parser* I<parser>, void *I<user_data>, void (*I<warning_fn>)(void *I<user_data>, const char *I<msg>, ...));

=item const char *B<librdf_parser_get_feature>(librdf_parser* I<parser>, librdf_uri *I<feature>);

=item int B<librdf_parser_set_feature>(librdf_parser* I<parser>, librdf_uri *I<feature>, const char *I<value>);

=item void B<librdf_parser_error>(librdf_parser* I<parser>, const char *I<message>, ...);

=item void B<librdf_parser_warning>(librdf_parser* I<parser>, const char *I<message>, ...);

=back

=head2 class stream

=over 4

=item librdf_stream* B<librdf_new_stream>(librdf_world *I<world>, void* I<context>, int (*I<end_of_stream>)(void*), librdf_statement* (*I<next_statement>)(void*), void (*I<finished>)(void*));

=item void B<librdf_free_stream>(librdf_stream* I<stream>);

=item int B<librdf_stream_end>(librdf_stream* I<stream>);

=item librdf_statement* B<librdf_stream_next>(librdf_stream* I<stream>);

=item void B<librdf_stream_set_map>(librdf_stream* I<stream>, librdf_statement* (*I<map>)(void* I<context>, librdf_statement* I<statement>), void* I<map_context>);

=item void B<librdf_stream_print>(librdf_stream *I<stream>, FILE *I<fh>);

=back


=head1 EXAMPLES

Would be here


=head1 SEE ALSO

libxml(4).

=head1 HISTORY

The B<redland> library was written by Dave Beckett from around June
2000 onwards.  It includes the expat XML parser originally by James
Clarke (optionally compiled) and the repat RDF/XML parser by Jason
Diamond (optionally compiled).


=head1 AUTHOR

 Dave Beckett
 http://purl.org/net/dajobe/
 Institute for Learning and Research Technology, University of Bristol

=cut
